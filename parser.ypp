%{
    #include "attributes.hpp"
    #include <iostream>
	#include <stdlib.h>
	#include <stdio.h>
	#include <vector>
	#include "output.hpp"
	#include "bp.hpp"
	#include "emitter.cpp"
    using namespace std;
	using namespace output;
    
	#define YYERROR_VERBOSE 1
	#define YYDEBUG 1
    int yylex();
	
	extern int yylineno;

    void yyerror(char const*);
	vector<bool> while_stack (false);
	vector<bool> funcs_stack;

	bool foundElse;
	string elseLabel;
	vector<int> elseNextList;
	string while_m1_nextLine;
	string while_m2_nextLine;
	int if_N_nextLine;
	bool one_statement;

	int inputCount = 0;
	string returnTypeFound = "return not done";
	bool foundMain = false;

	vector<int> oldOrTrueList;
	vector<int> oldAndFalseList;

	RegisterHandler register_handler;
	emitter e(register_handler);
	#ifndef YYSTYPE
	#define YYSTYPE VarType*
	#endif
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN WHILE BREAK SC COMMA LBRACE RBRACE ID NUM STRING 
%left OR AND 
%nonassoc RELOP_NORMAL
%left LBRACK RBRACK LPAREN RPAREN BINOP_ADD
%left BINOP_MULT RELOP_EQUAL
%right ASSIGN NOT
%nonassoc IF
%nonassoc ELSE
	

%%

Program : 		Funcs	{
						}
;

Funcs :		/*epsilon*/
		| FuncDecl Funcs
;

FuncDecl :		RetType ID LPAREN Formals RPAREN {
													e.funcStart($2->getName());
													
													
													string returnType = $1->getType()+"_"+$4->getType();
													InsertFunction($2->getName(), returnType,$4->getEntryKinds(), $4->getArgNames());
													$2->setType(returnType);
													dynamic_cast<TEntry*>($2)->setKind(Func);
													if(returnType == "VOID_VOID" && $2->getName()=="main"){
														if(foundMain){
															errorMismatch(yylineno); 
															PopAllStacks();
															exit(0);
														}
														foundMain = true;
													}
												} LBRACE Statements RBRACE { funcs_stack.pop_back();
																				string functionType = $1->getType();
																				if(returnTypeFound!="return not done"){
																					if((returnTypeFound!=functionType) && (functionType!="INT" || returnTypeFound!="BYTE")){//todo more cases
																						errorMismatch(yylineno); 
																						PopAllStacks();
																						exit(0);
																					}
																				}
																				returnTypeFound = "return not done";
																			if(one_statement){
																				string end_label = e.getEndMainLabel();
																				CodeBuffer::instance().bpatch($8->getNextList(),end_label);
																			}
																			ExitScope();
																			e.funcEnd($2->getName());
																			}
																			
;

RetType :		Type {  funcs_stack.push_back(false); $$ = new VarType(); $$->setType($1->getType());}
		| VOID {  funcs_stack.push_back(true); $$ = new VarType(); $$->setType("VOID");}
;

Formals :		/*epsilon*/										{$$ = new VarType();
																$$->setType("VOID");
																vector<EntryKind> vec;
																$$->setEntryKinds(vec);
																vector<string> names;
																$$->setArgNames(names);
																}
		| FormalsList											{$$ = new VarType();
																$$->setType($1->getType());
																$$->setEntryKinds($1->getEntryKinds());
																$$->setArgNames($1->getArgNames());}
;

FormalsList :		FormalDecl									{$$ = new VarType(); $$->setType($1->getType());
																$$->addEntryKind($1->getEntryKinds()[0]);
																$$->addArgName($1->getArgNames()[0]);}
		| FormalDecl COMMA FormalsList							{$$->setType($1->getType() + "," + $3->getType());
																vector<EntryKind> vec;
																vec.insert(vec.begin(),$1->getEntryKinds()[0]);
																vector<EntryKind> v2 = $3->getEntryKinds();
																vec.insert(vec.end(), v2.begin(), v2.end());
																$$->setEntryKinds(vec);

																vector<string> vec2;
																vec2.insert(vec2.begin(),$1->getArgNames()[0]);
																vector<string> v3 = $3->getArgNames();
																vec2.insert(vec2.end(), v3.begin(), v3.end());
																$$->setArgNames(vec2);
																}	
;

FormalDecl :		Type ID										{$$->setType($1->getType());
																$$->addEntryKind(Var);
																$$->addArgName($2->getName());
																dynamic_cast<TEntry*>($2)->setKind(Var);}

		| Type ID LBRACK NUM RBRACK								{int number = $4->getIntVal();
																if (number <= 0 || number >= 256){
																	errorInvalidArraySize(yylineno,$2->getName()); 
																	PopAllStacks();
																	exit(0);
																}	
																string valString = numberToString(number);
																$$->setType($1->getType() + "[" + valString + "]");
																dynamic_cast<TEntry*>($2)->setKind(Var);
																$$->addEntryKind(Array);
																$$->addArgName($2->getName());
																}

		| Type ID LBRACK NUM B RBRACK							{int number = $4->getIntVal();
																if(number >= 256){
																	errorByteTooLarge(yylineno, numberToString(number));
																	PopAllStacks();
																	exit(0);
																}
																if(number <= 0){
																	errorInvalidArraySize(yylineno,$2->getName()); 
																	PopAllStacks();
																	exit(0);
																}	
																string valString = numberToString(number);
																$$->setType($1->getType() + "[" + valString + "]");
																dynamic_cast<TEntry*>($2)->setKind(Var);
																$$->addEntryKind(Array);
																$$->addArgName($2->getName());}
;

Statements :		Statement	{$$->setNextList($1->getNextList()); one_statement = true;}
		| Statements {
					string newLabel = CodeBuffer::instance().genLabel();
					//cout << "1 :" << newLabel << endl;
					CodeBuffer::instance().bpatch($1->getNextList(),newLabel);}
		 Statement {$$->setNextList($3->getNextList()); one_statement = false;}	
;
 
Statement :		LBRACE {StartScope();} Statements {ExitScope(); 
																vector<int> list = $3->getNextList(); 
																
																$$->setNextList(list);
																
																} RBRACE
		| Type ID SC											{
																if(isIdentifierExists($2->getName())){
																	errorDef(yylineno, $2->getName());
																	PopAllStacks();
																	exit(0);
																}
																$2->setType($1->getType()); 
																
																dynamic_cast<TEntry*>($2)->setKind(Var);
																InsertVar($2->getName(),$1->getType(),$2);
																string reg = register_handler.getAvailReg();
																			
																if($1->getType() == "INT" || $1->getType() == "BYTE"){
																	e.li(reg,"0");
																	e.pushRegister(reg);
																}
																else {
																	//todo handle false var initialize
																}
																
																register_handler.returnRegisterToPool(reg);
																
																}
		| Type ID ASSIGN Exp SC									{
																if(isIdentifierExists($2->getName())){
																	errorDef(yylineno, $2->getName());
																	PopAllStacks();
																	exit(0);
																}
																if($1->getType() != $4->getType()){
																	if($1->getType()!="INT" || $4->getType()!="BYTE"){
																		errorMismatch(yylineno);
																		PopAllStacks();
																		exit(0);
																	}	
																}//script killer
																$2->setType($1->getType());
																dynamic_cast<TEntry*>($2)->setKind(Var);
																InsertVar($2->getName(),$1->getType(),$2);
																
																TEntry* t = findByID($2->getName());
																string reg;
																if(t->getType()=="INT" || t->getType()=="BYTE"){
																	reg = $4->getRegister();
																	//e.pushRegister(reg);
																	e.storeVariable(reg,t->getOffset());
																}
																else if(t->getType()=="BOOL"){
																		reg = register_handler.getAvailReg();
																		e.booleanRegisterHandle(reg, $4->getTrueList(), $4->getFalseList());
																		e.storeVariable(reg,t->getOffset());
																	}
																register_handler.returnRegisterToPool(reg);
																
																}
		| Type ID LBRACK NUM RBRACK SC							{
																if(isIdentifierExists($2->getName())){
																	errorDef(yylineno, $2->getName());
																	PopAllStacks();
																	exit(0);
																}
																int number = $4->getIntVal();

																if(number <= 0 || number >= 256){
																	errorInvalidArraySize(yylineno,$2->getName()); 
																	PopAllStacks();
																	exit(0);
																}
																string valString = numberToString(number);
																$2->setType($1->getType() + "[" + valString + "]");
																dynamic_cast<TEntry*>($2)->setKind(Array);
																InsertArray($2->getName(),$1->getType(), number);

																string reg = register_handler.getAvailReg();
																			
																if($1->getType() == "INT" || $1->getType() == "BYTE"){
																	e.li(reg,"0");
																	e.initArray(reg,$4->getIntVal());
																}
																else {
																	//TODO: handle false array initialize
																}
																
																register_handler.returnRegisterToPool(reg);
																			
																}
		| Type ID LBRACK NUM B RBRACK SC						{
																if(isIdentifierExists($2->getName())){
																	errorDef(yylineno, $2->getName());
																	PopAllStacks();
																	exit(0);
																}
																int number = $4->getIntVal();
																if(number >= 256){
																	errorByteTooLarge(yylineno, numberToString(number));
																	PopAllStacks();
																	exit(0);
																}
																if(number <= 0){
																	errorInvalidArraySize(yylineno,$2->getName()); 
																	PopAllStacks();
																	exit(0);
																}	
																string valString = numberToString(number);
																$2->setType($1->getType() + "[" + valString + "]");
																dynamic_cast<TEntry*>($2)->setKind(Array);
																InsertArray($2->getName(),$1->getType(), number);
																}
		| ID ASSIGN Exp SC										{
																TEntry* t = findByID($1->getName());
																if(!t){
																	errorUndef(yylineno, $1->getName());
																	PopAllStacks();
																	exit(0);
																}
																if (t->getKind() == Array) {
																	size_t pos = $3->getName().find("[");
																	if (pos != std::string::npos){
																		errorMismatch(yylineno); 
																		PopAllStacks();
																		exit(0);
																	}	
																	TEntry* t2 = findByID($3->getName());
																	if(!t2){
																		errorUndef(yylineno, $1->getName());
																		PopAllStacks();
																		exit(0);
																	}
																	if(t2->getKind() != Array){
																		errorMismatch(yylineno); 
																		PopAllStacks();
																		exit(0);
																	}
																	/*size_t pos = $2->getType().find("[");
																	if (pos != std::string::npos){
																		errorMismatch(yylineno); 
																		exit(0);
																	}*/	
																	if((t->getType()!=t2->getType()) || 
																		(t->getArrSize()!=t2->getArrSize())){
																		errorMismatch(yylineno); 
																		PopAllStacks();
																		exit(0);
																	}
																	
																	e.arrayCopy(t, t2);
																}
																else if(t->getKind() == Func){
																		errorUndef(yylineno, $1->getName());
																		PopAllStacks();
																		exit(0);
																}
																else {
																	if((t->getType()!=$3->getType()) &&
																	(t->getType()!="INT" && $3->getType()!="BYTE")){
																			errorMismatch(yylineno); 
																			PopAllStacks();
																			exit(0);
																		}	
																	string reg;
																	if(t->getType()=="INT" || t->getType()=="BYTE"){
																		reg = $3->getRegister();
																		e.storeVariable(reg, t->getOffset());
																	}
																	else if(t->getType()=="BOOL"){
																		reg = register_handler.getAvailReg();
																		e.booleanRegisterHandle(reg, $3->getTrueList(), $3->getFalseList());
																		e.storeVariable(reg,t->getOffset());
																	}
																
																	register_handler.returnRegisterToPool(reg);
																	
																}
														
																}

																

		| ID LBRACK Exp RBRACK ASSIGN Exp SC					{
																	if($3->getType()!="BYTE" && $3->getType()!="INT") {
																		errorMismatch(yylineno);
																		PopAllStacks();
																		exit(0);
																	}
																	
																	TEntry* t = findByID($1->getName());
																	if(!t){
																		errorUndef(yylineno, $1->getName());
																		PopAllStacks();
																		exit(0);
																	}
																	
																	if(t->getKind() != Array){
																		errorMismatch(yylineno);
																		PopAllStacks();
																		exit(0);
																	}
																	
																	if((t->getType() != $6->getType())&&((t->getType() != "INT") ||
																		($6->getType() != "BYTE"))){
																		errorMismatch(yylineno);
																		PopAllStacks();
																		exit(0);
																	}
																	
																	e.arrayIsInRange(numberToString(t->getArrSize()), $3->getRegister());
																	
																	string resreg = register_handler.getAvailReg();
																
																	e.li(resreg, numberToString(t->getOffset()));
																	e.add(resreg, resreg, $3->getRegister());
																	e.mul(resreg, resreg, numberToString(STACK_ENTRY_SIZE));
																	e.sub(resreg, fp_reg, resreg);
																	e.sw($6->getRegister(), "(" + resreg + ")");
																	
																	register_handler.returnRegisterToPool(resreg);
																}
		| Call SC
		| RETURN SC {
			if (funcs_stack.empty() || !funcs_stack.back()) {
				errorMismatch(yylineno);
				PopAllStacks();
				exit(0);
			}
			returnTypeFound = "VOID";
			e.jr();
		}
		| RETURN Exp SC {
			if (funcs_stack.empty() || funcs_stack.back()) {
				errorMismatch(yylineno);
				PopAllStacks();
				exit(0);
			}
			returnTypeFound = $2->getType();
			if($2->getIsNamed()) {
				TEntry* t = findByID($2->getName());
				if(t){
					size_t position = $2->getType().find("[");
					if (position != std::string::npos){
						errorMismatch(yylineno); 
						PopAllStacks();
						exit(0);
					}
					if(t->getKind() == Func) {
						if (t->getType() != returnTypeFound) {
							if (t->getType() != "INT" || returnTypeFound != "BYTE") {
								errorMismatch(yylineno);
								PopAllStacks();
								exit(0);
							}
						}
					}
				}
			}
			string reg;
			if($2->getType()=="INT" || $2->getType()=="BYTE"){
				reg = $2->getRegister();
				register_handler.returnRegisterToPool($2->getRegister());
				
			}
			else if($2->getType()=="BOOL"){
				reg = register_handler.getAvailReg();
				e.booleanRegisterHandle(reg, $2->getTrueList(), $2->getFalseList());
			}
			e.mov("$v0",reg);
			register_handler.returnRegisterToPool(reg);
			e.jr();
		}
		| IF  LPAREN Exp RPAREN {
			if($3->getType()!="BOOL"){
				errorMismatch(yylineno);
				PopAllStacks();
				exit(0);
			}
			StartScope();
			
			string newLabel = CodeBuffer::instance().genLabel();
								//cout << "2 :" << newLabel << endl;
			CodeBuffer::instance().bpatch($3->getTrueList(),newLabel);
			
			} 
		Statement {ExitScope();	} 
		ElsePart {

			if(foundElse){
				CodeBuffer::instance().bpatch($3->getFalseList(),elseLabel);
				//string nextLine = CodeBuffer::instance().genLabel();

				vector<int> N_nextlist = makelist(if_N_nextLine);
				vector<int> temp;
				if($6->getNextList().size()==0){
					temp = N_nextlist;
				}
				else {
					temp = merge($6->getNextList(),N_nextlist);
				}
				
				$$->setNextList(merge(temp,elseNextList));
			}
			else {
				
				$$->setNextList(merge($3->getFalseList(),$6->getNextList()));
				
				//string nextLine = CodeBuffer::instance().genLabel();
				//cout << "nextline :" << nextLine << endl;
				//CodeBuffer::instance().bpatch($3->getFalseList(),nextLine);
			}
			foundElse = false;
		}
		| WHILE {
			string nextLine = CodeBuffer::instance().genLabel();
					while_m1_nextLine = nextLine;
					
					} 
		LPAREN Exp RPAREN 					{ if($4->getType()!="BOOL"){
														
														errorMismatch(yylineno);
														PopAllStacks();
														exit(0);
												}
													
												string nextLine = CodeBuffer::instance().genLabel();
												while_m2_nextLine = nextLine;
												
												while_stack.push_back(true); StartScope(); } 
		Statement 																{
																					while_stack.pop_back(); 
																					
																					if($4->getType()!="BOOL"){
																						errorMismatch(yylineno); 
																						PopAllStacks();
																						exit(0);
																					}
																						
																					ExitScope();	
																					CodeBuffer::instance().bpatch($7->getNextList(),while_m1_nextLine);
																					CodeBuffer::instance().bpatch($4->getTrueList(),while_m2_nextLine);
																					$$->setNextList($4->getFalseList());
																					CodeBuffer::instance().emit("j " + while_m1_nextLine);
																				}
		| BREAK SC {
			if (!while_stack.back()) {
				errorUnexpectedBreak(yylineno);
				PopAllStacks();
				exit(0);
			}
		}
;
ElsePart :		/*epsilon*/ %prec IF
		{
		foundElse = false;}
		| ELSE {if_N_nextLine = e.gotoEmpty(); StartScope();
			foundElse = true;
			
			elseLabel = CodeBuffer::instance().genLabel();
								//cout << "4 :" << elseLabel << endl;
			}
		Statement {ExitScope();
		elseNextList = $3->getNextList();} %prec ELSE
;
Call :		ID LPAREN ExpList
			{ 
				e.onFunctionCall($1->getName(),$3->getRegisterList());
			} RPAREN						{e.onFunctionReturn($3->getRegisterList()); TEntry* t;
															string old3 = $3->getType();
															if($1->getName()=="print"){
																$$->setType("VOID");
																if($3->getType()!="STRING"){
																	string temps = $1->getName();
																	vector<string> tempv;
																	tempv.push_back("STRING");
																	errorPrototypeMismatch(yylineno, temps, tempv);
																	PopAllStacks();
																	exit(0);
																}	
															}
															else if($1->getName()=="printi"){
																$$->setType("VOID");
																if($3->getType()!="INT" && $3->getType()!="BYTE"){
																	string temps = $1->getName();
																	vector<string> tempv;
																	tempv.push_back("INT");
																	errorPrototypeMismatch(yylineno, temps, tempv);
																	PopAllStacks();
																	exit(0);
																}
															}
															else {
																t = findByID($1->getName());
																if(t->getKind()!=Func){
																	errorUndefFunc(yylineno, $1->getName());
																	PopAllStacks();
																	exit(0);
																}	
																$$->setType(t->getType());	//find retValue type
															}
															t = findByID($1->getName());
															if(!doesFunctionExist($1->getName(), $1->getType() + "_" +old3)){
																vector<TEntry> vecEntry = t->getFuncArgs();
																vector<string> vecTypes;
																for(int i=0;i<vecEntry.size();i++){
																		if(vecEntry[i].getKind() == Array){
																			vecTypes.push_back(vecEntry[i].getType() + "[" + numberToString(vecEntry[i].getArrSize()) + "]");
																		}
																		else {
																			vecTypes.push_back(vecEntry[i].getType());
																		}
																}
																errorPrototypeMismatch(yylineno, $1->getName(), vecTypes); 
																PopAllStacks();
																exit(0);
															}	
															
															}
		| ID LPAREN { 
				vector<string> emptyVec;
				e.onFunctionCall($1->getName(),emptyVec);
			} RPAREN									{vector<string> emptyVec;
				e.onFunctionReturn(emptyVec); 
															
															TEntry* t = findByID($1->getName());
															if(!t || t->getKind()!=Func){
																
																errorUndefFunc(yylineno, $1->getName());
																PopAllStacks();
																exit(0);
															}
															
															$$->setType(t->getType());
															if(!doesFunctionExist($1->getName(), t->getType() + "_")){
																vector<TEntry> vecEntry = t->getFuncArgs();
																vector<string> vecTypes;
																for(int i=0;i<vecEntry.size();i++){
																	if(vecEntry[i].getKind() == Array){
																		vecTypes.push_back(vecEntry[i].getType() + "[" + numberToString(vecEntry[i].getArrSize()) + "]");
																	}
																	else {
																		vecTypes.push_back(vecEntry[i].getType());
																	}
																}
																errorPrototypeMismatch(yylineno, $1->getName(), vecTypes); 
																PopAllStacks();
																exit(0);
															}

															}
;

ExpList :		Exp											{
															$$->setType($1->getType());
															
															if($1->getType()=="STRING"){
																string reg = register_handler.getAvailReg();
																e.la(reg, $1->getStringLabel());
																$$->addRegisterToList(reg);
																//register_handler.returnRegisterToPool(reg);
															}
															else if($1->getType()=="BOOL"){
																string reg = register_handler.getAvailReg();
																e.booleanRegisterHandle(reg, $1->getTrueList(), $1->getFalseList());
																$$->addRegisterToList(reg);
															}
															else {
																$$->addRegisterToList($1->getRegister());
															}
															
															}
		| Exp COMMA ExpList									{
															$$->setType($1->getType() + "," + $3->getType());
															vector<string> list = $3->getRegisterList();
															$$->addRegisterToList($1->getRegister());
															for(int i=0;i<list.size();i++){
																$$->addRegisterToList(list[i]);
															}
															}
;

Type :		INT
		| BYTE
		| BOOL
;

Exp :		LPAREN Exp RPAREN								{$$->setType($2->getType());
															if($2->getType()!="BOOL"){
																$$->setRegister($2->getRegister());
															}
															$$->setTrueList($2->getTrueList());
															$$->setFalseList($2->getFalseList());
															
															
															}
		| ID LBRACK Exp RBRACK								{
															TEntry* t = findByID($1->getName());
															if(!t) {
																errorUndef(yylineno, $1->getName());
																PopAllStacks();
																exit(0);
															}
															if($3->getType()!="INT" && $3->getType()!="BYTE" || t->getKind()!=Array) {
																errorMismatch(yylineno); 
																PopAllStacks();
																exit(0);
															}
															
															e.arrayIsInRange(numberToString(t->getArrSize()), $3->getRegister());
																
															string resreg = register_handler.getAvailReg();
																
															e.li(resreg, numberToString(t->getOffset()));
															e.add(resreg, resreg, $3->getRegister());
															e.mul(resreg, resreg, numberToString(STACK_ENTRY_SIZE));
															e.sub(resreg, fp_reg, resreg);
															e.lw(resreg, "(" + resreg + ")");
															//register_handler.returnRegisterToPool(resreg);	
															$$->setRegister(resreg);
															$$->setName($1->getName() + "[]");	
															$$->setType(t->getType());
															
															}
		| Exp BINOP_MULT Exp								{
															
															if(($1->getType() != "INT" && $1->getType() != "BYTE")
																||($3->getType() != "INT" && $3->getType() != "BYTE")){
																errorMismatch(yylineno); 
																PopAllStacks();
																exit(0);
															}
															
															if(($1->getType() == "INT") || ($3->getType() == "INT"))
																$$->setType("INT");
															else 
																$$->setType("BYTE");
															string reg1 = $1->getRegister();
															string reg2 = $3->getRegister();
															if($2->getOp()=="*"){
																e.mul(reg1,reg1,reg2);
															}
															else {
																e.div(reg1,reg1,reg2);
															}	
															$$->setRegister(reg1);
															if($$->getType()=="BYTE"){
																e.zeroTopBits(reg1);
															}
															register_handler.returnRegisterToPool(reg2);
															
															}

		| Exp BINOP_ADD Exp									{
															if(($1->getType() != "INT" && $1->getType() != "BYTE")
																||($3->getType() != "INT" && $3->getType() != "BYTE")){
																errorMismatch(yylineno);
																PopAllStacks();
																exit(0);
															}
															
															if(($1->getType() == "INT") || ($3->getType() == "INT"))
																$$->setType("INT");
															else 
																$$->setType("BYTE");
															string reg1 = $1->getRegister();
															string reg2 = $3->getRegister();
															
															if($2->getOp()=="+"){
																
																e.add(reg1,reg1,reg2);
															}
															else {
																e.sub(reg1,reg1,reg2);
															}
															$$->setRegister(reg1);
															if($$->getType()=="BYTE"){
																e.zeroTopBits(reg1);
															}
															register_handler.returnRegisterToPool(reg2);
															
															}
		| ID												{
															if(!isIdentifierExists($1->getName())){
																	errorUndef(yylineno, $1->getName());
																	PopAllStacks();
																	exit(0);
																}
															$$->setName($1->getName());
															TEntry* t = findByID($1->getName());
															if(t->getKind() == Array){
																$$->setType(t->getType() + "[" + numberToString(t->getArrSize()) + "]"); 
															}
															else {
																$$->setType(t->getType());
																if(t->getType()!= "BOOL"){
																	$$->setRegister(register_handler.getAvailReg());
																	
																	e.loadVariable($$->getRegister(), t->getOffset());
																}
																else {
																	string reg = register_handler.getAvailReg();
																	int line = e.bne(reg, "0");
																	$$->setTrueList(makelist(line));
																	int nextLine = e.gotoEmpty();
																	$$->setFalseList(makelist(nextLine));
																	register_handler.returnRegisterToPool(reg);
																}
																
															}
														

															
															}
		| Call												{$$->setType($1->getType());
															string reg = register_handler.getAvailReg();
															e.mov(reg,"$v0");
															$$->setRegister(reg);
		
		}
		| NUM												{$$->setType("INT");
															$$->setIntVal($1->getIntVal());
															string reg = register_handler.getAvailReg();
																		
															e.li(reg,numberToString($1->getIntVal()));
															$$->setRegister(reg);
															}
		| NUM B												{$$->setType("BYTE");
															int val = $1->getIntVal();
															if(val > 255){
																errorByteTooLarge(yylineno, numberToString(val)); 
																PopAllStacks();
																exit(0);
															}
															$$->setIntVal($1->getIntVal());	
															string reg = register_handler.getAvailReg();
																		
															e.li(reg,numberToString($1->getIntVal()));
															$$->setRegister(reg);
															}
		| STRING											{
			
															string string_label = "input" + numberToString(inputCount++);
															string long_string_label = string_label + ":    .asciiz " + $1->getStringVal();
															CodeBuffer::instance().emitData(long_string_label);
															$$->setStringLabel(string_label);
															}
		| TRUE 												{$$->setType("BOOL");
															$$->setBoolVal(true);
															int nextLine = e.gotoEmpty();
															//cout << "nextLineTrue :" << nextLine << endl;
															$$->setTrueList(makelist(nextLine));
															//cout << "1     " << $$->getTrueList()[0] << endl;
															}
		| FALSE 											{$$->setType("BOOL");
															int nextLine = e.gotoEmpty();
															//cout << "nextLineFalse :" << nextLine << endl;
															$$->setFalseList(makelist(nextLine));
																		
															}

		| NOT Exp 											{if($2->getType() != "BOOL"){
																errorMismatch(yylineno); 
																PopAllStacks();
																exit(0);
															}	
															
															$$->setType("BOOL");
															
															vector<int> oldTrueList = $2->getTrueList();
															vector<int> oldFalseList = $2->getFalseList();
															//cout << "trueListSize " << oldTrueList.size() << endl;
															//cout << "falseListSize " << oldFalseList.size() << endl;
															$$->setTrueList(oldFalseList);
															$$->setFalseList(oldTrueList);
															//cout << "trueListSize2 " << oldTrueList.size() << endl;
															//cout << "falseListSize2 " << oldFalseList.size() << endl;
															//cout << "trueListSizeNew " << $$->getTrueList().size() << endl;
															//cout << "falseListSizeNew " << $$->getFalseList().size() << endl;
															//cout << $$->getTrueList()[0] << endl;
															}

		| Exp AND {
			oldAndFalseList = $1->getFalseList();
			string nextLine = CodeBuffer::instance().genLabel();
			CodeBuffer::instance().bpatch($1->getTrueList(),nextLine);
		}
		Exp 										{if($1->getType() != "BOOL" || $4->getType() != "BOOL") {
																errorMismatch(yylineno); 
																PopAllStacks();
																exit(0);
															}	
															$$->setType("BOOL");
															$$->setTrueList($4->getTrueList());
															$$->setFalseList(merge(oldAndFalseList,$4->getFalseList()));
															}

		| Exp OR {
			
			string nextLine = CodeBuffer::instance().genLabel();
			
			oldOrTrueList = $1->getTrueList();
			CodeBuffer::instance().bpatch($1->getFalseList(),nextLine);
		}
		Exp 										{
															if($1->getType() != "BOOL" || $4->getType() != "BOOL") {
																errorMismatch(yylineno); 
																PopAllStacks();
																exit(0);
															}	
															$$->setType("BOOL");
															
															$$->setTrueList(merge(oldOrTrueList,$4->getTrueList()));
															
															$$->setFalseList($4->getFalseList());
															}

		| Exp RELOP_NORMAL Exp 								{if(($1->getType() != "INT" && $1->getType() != "BYTE")
																||($3->getType() != "INT" && $3->getType() != "BYTE")){
																errorMismatch(yylineno);
																PopAllStacks();
																exit(0);
															}	
															$$->setType("BOOL");
															
															int nextLine = e.ifInstruction($1->getRegister(), $3->getRegister(), $2->getOp());
															$$->setTrueList(makelist(nextLine));
															nextLine = e.gotoEmpty();
															$$->setFalseList(makelist(nextLine));
															
															
															}

		| Exp RELOP_EQUAL Exp 								{if(($1->getType() != "INT" && $1->getType() != "BYTE")
																||($3->getType() != "INT" && $3->getType() != "BYTE")){
																errorMismatch(yylineno); 
																PopAllStacks();
																exit(0);
															}	
															$$->setType("BOOL");
															
															int nextLine = e.ifInstruction($1->getRegister(), $3->getRegister(), $2->getOp());
															$$->setTrueList(makelist(nextLine));
															nextLine = e.gotoEmpty();
															$$->setFalseList(makelist(nextLine));
															}
;

%%

int main() {
	CodeBuffer::instance().emitData("errorOutOfBounds: .asciiz \"Error index out of bounds\n\"");
	CodeBuffer::instance().emitData("errorZeroDiv: .asciiz \"Error division by zero\n\"");
	
	//yydebug = 1;
	__init_stacks();
	/// print imp.



	int ret = e.buildMain();

	vector<int> mainList = CodeBuffer::instance().makelist(ret);

	int status = yyparse();

	if(foundMain) {
		string mainLabel = getFunctionLabel("main");
		CodeBuffer::instance().bpatch(mainList,mainLabel);
	}

	e.funcStart("print");
	emit("lw $a0,0($sp)");
	emit("li $v0,4");
	emit("syscall");
	e.funcEnd("print");

	e.funcStart("printi");
	emit("lw $a0,0($sp)");
	emit("li $v0,1");
	emit("syscall");
	e.funcEnd("printi");

	/// div by zero error fun
	emit("labelZeroDiv:");
	string error_reg = register_handler.getAvailReg();
	e.la(error_reg, "errorZeroDiv");
	e.pushRegister(error_reg);
	register_handler.returnRegisterToPool(error_reg);
	e.jal("_print_");
	emit("li $v0,10"); //terminate program
	emit("syscall");
	emit("");

	/// index out of array range error fun
	emit("labelOutOfRange:");
	error_reg = register_handler.getAvailReg();
	e.la(error_reg, "errorOutOfBounds");
	e.pushRegister(error_reg);
	register_handler.returnRegisterToPool(error_reg);
	e.jal("_print_");
	emit("li $v0,10"); //terminate program
	emit("syscall");
	
	__destroy_stacks();
	CodeBuffer::instance().printDataBuffer();
	cout << endl;
	CodeBuffer::instance().printCodeBuffer();
    return status;
}
void yyerror(const char*) { errorSyn(yylineno); exit(0); }
